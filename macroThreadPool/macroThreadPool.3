.\" -*- mode: troff; coding: utf-8 -*-
.TH "macroThreadPool.h" "3" "2025-06-03" "grauho 2025" "Macro Thread Pool Header"
.SH NAME
.LP
macroThreadPool.h, A Dynamically Generated pthread Thread Pool 
.SH LIBRARY
.LP
#include \(lqmacroThreadPool.h\(rq
.SH DESCRIPTION
.LP
This header contains a number of macros used to dynamically defining and 
interact with a thread pool structure. This header is an abstraction over the
pthread API and as such if on a non-POSIX compliant system a wrapper providing
the aforementioned API is required.
.PP
The header contains five macros, three of which the user may interact with
directly. These three are MACRO_THREAD_POOL_COMPLETE, 
MACRO_THREAD_POOL_PROTOTYPES, and MACRO_THREAD_POOL_DEFINITIONS. Using 
these the actual API of the library described below can be dynamically 
generated with user supplied arguments. 
.PP
The functions and structure definitions generated by these macros can either be
forced to be static or can be used to generate a more traditional pair of
translation unit and header if used separately in a .c and .h file 
respectively.
.SH SYNOPSYS
.LP
.EX
#include \(dqmacoThreadPool.h\(dq

MACRO_THREAD_POOL_PROTOTYPE(NAME, TYPE, FUNC);
MACRO_THREAD_POOL_DEFINITIONS(NAME, TYPE, FUNC);
MACRO_THREAD_POOL_COMPLETE(NAME, TYPE, FUNC);

struct {NAME}ThreadArgs;
struct {NAME}JobQueue;
struct {NAME}ThreadPool;

void {NAME}EnqueueJob(struct {NAME}ThreadPool *pool, {TYPE} in);
void* {NAME}ThreadRoutine(void *queue);
struct {NAME}ThreadPool* {NAME}NewThreadPool(const size_t num_threads,
    const size_t max_jobs);
void {NAME}CleanupThreadPool(struct {NAME}ThreadPool *pool);
void {NAME}WaitOnIdle(struct {NAME}ThreadPool *pool);

Expected worker function signature:
void FUNC(TYPE)
.EE
.SH DESCRIPTION
.SS
MACRO_THREAD_POOL_PROTOTYPES()
.LP
Defines the structure definition for the vector containing the data type
indicated by \(oqtype\(cq with the namespace \(oqNAME\(cq. This can be used to generate
a header file without including the generated function definitions. Must be
followed by a semicolon.
.SS
MACRO_THREAD_POOL_DEFINITIONS()
.LP
Defines the generated function definitions to go with the aforementioned 
prototypes. This must be invoked after the prototypes function and have access
to the prototype\(cqs scope as that contains the structure definition. \(oqtype\(cq and
\(oqNAME\(cq \fBMUST MATCH\fR those used in MACRO_THREAD_POOL_PROTOTYPES. 
Must be followed by a semicolon.
.SS
MACRO_THREAD_POOL_PROTOTYPES()
.LP
Defines the two above functions one after another, ensuring that the arguments
for both are consistent. Suitable for if using this library in only a single
file and an external header is not needed. Must be followed by a semicolon.
.SS
{NAME}EnqueueJob()
.LP
Adds a new job to the thread pool job queue. This function requires only the
pointer to the thread pool and an argument of type {TYPE} that the user defined
when the dynamic API was generated. The type argument will end up being passed
through to whatever function the user defined as {FUNC} in the above macros. 
Currently there is not output stack that the thread pool manages so if one
desires to get information out of the thread pool the {TYPE} variable should
contain the appropriate fields to do so.
.SS
{NAME}ThreadRoutine()
.LP
An internal function that the user should not need to interact with directly.
In short, terminates the thread if the terminate signal is passed through with
the thread arguments, otherwise calls the provided function with the passed
through user payload described in EnqueueJob. 
.SS
{NAME}NewThreadPool()
.LP
Creates a new thread pool containing the requested number of thread workers. 
Also initializes the mutexes required to make the thread pool function. This 
function calls \(oqcalloc\(cq. In future this allocation may be abstracted in a macro
to allow the user to define an alternative allocation method. 
.SS
{NAME}CleanupThreadPool()
.LP
Send a signal to each of the active threads to terminate before freeing the 
thread pool and all of it\(cqs associated worker threads. 
.SS
{NAME}WaitOnIdle()
.LP
Functions as a non-destructive thread join. This function waits to return until
all of the currently enqueued jobs have been dispatched and completed. In 
future a version with a \(oqtimeout\(cq option may be introduced. 
.SH RETURN STATUS
.LP
Most functions return void with the exception of NewThreadPool which returns
a pointer to the newly created thread pool structure. In future a more robust
error code system may be introduced. Should one want to get information out
of the worker thread function itself that should be accomplished via the {TYPE} 
one defines when generating the dynamic API.
.SH ENVIRONMENT
.LP
When compiling the following compile time definitions can be made to overwrite
default library behavior. Each of the constituent macros must be defined if
using one of these overwrites:
.SS
MACRO_THREAD_POOL_CUSTOM_ALLOC:
.LP
Overwrites default definitions for MTP_CALLOC and MTP_FREE. Doing so removes 
the direct dependency on stdlib.h.
.SH VERSIONS
.LP
0.0.1
.SH STANDARDS
.LP
POSIX 2008
.PP
C89/90
.SH CAVEATS
.LP
This produces a single function thread pool which is to say it will only ever
run the function provided in the API generation macro. For this reason one will
either need to create multiple thread pools for different kinds of jobs or 
alternatively have job marshalling occur in {FUNC}.
.PP
Currently there is no handling for if a thread hangs when executing the user\(cqs
provided {FUNC}, should this happen the entire program will hang waiting on
either WaitOnIdle or on CleanupThreadPool as each essentially tries to execute
a join. 
.SH BUGS
.LP
Please report any bugs to the appropriate bug section for the repository 
hosting service you found this project on. 
.SH LICENSE
.LP
Provided under the terms of the BSD 4-Clause license. A copy of which can be
found in the body of macroThreadPool.h as well as in the attached LICENSE.txt
included with your copy of this repository.
.SH AUTHORS
.LP
.EX
Grauho <grauho@proton.me> 
.EE
.SH COPYRIGHT
.LP
Copyright \(co Grauho 2025, All Rights Reserved 
